nextflow_process {

    name "Test Process RGI_PREPARECARDDB"
    script "../main.nf"
    process "RGI_PREPARECARDDB"

    tag "modules"
    tag "modules_nfcore"
    tag "rgi"
    tag "rgi/preparecarddb"
    tag "untar"

    setup {
        run("UNTAR") {
            script "modules/nf-core/untar/main.nf"
            process {
                """
                file('https://card.mcmaster.ca/latest/data', checkIfExists: true).copyTo('card-data.tar.bz2')

                input[0] = [
                    [ ],
                    file("card-data.tar.bz2")
                ]
                """
            }
        }
    }

    test("rgi/preparecarddb - with input data (load only mode)") {

        when {
            process {
                """
                input[0] = UNTAR.out.untar.map{ it[1] }
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(
                    process.out.versions,
                    process.out.tool_version,
                    process.out.db_version,
                    file(process.out.db.get(0)).list().sort()
                    ).match() }
            )
        }
    }

    test("rgi/preparecarddb - with input data (load only mode) - stub") {

        options "-stub"

        when {
            process {
                """
                input[0] = UNTAR.out.untar.map{ it[1] }
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(process.out).match() }
            )
        }
    }

    test("rgi/preparecarddb - without input (download and process mode)") {

        when {
            process {
                """
                input[0] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(
                    process.out.versions,
                    process.out.tool_version,
                    process.out.db_version,
                    file(process.out.db.get(0)).list().sort()
                    ).match() }
            )
        }
    }

    test("rgi/preparecarddb - without input (download and process mode) - stub") {

        options "-stub"

        when {
            process {
                """
                input[0] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(process.out).match() }
            )
        }
    }

    test("rgi/preparecarddb - validate database structure with input") {

        when {
            process {
                """
                input[0] = UNTAR.out.untar.map{ it[1] }
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                // Check output database structure
                { assert process.out.db },
                { assert path(process.out.db.get(0)).exists() },
                { assert path(process.out.db.get(0)).isDirectory() },
                
                // Check for localDB directory (created by rgi load)
                { assert path("${process.out.db.get(0)}/localDB").exists() },
                
                // Check for card.json
                { assert path("${process.out.db.get(0)}/card.json").exists() },
                
                // Check for FASTA files
                {
                    def db_dir = process.out.db.get(0)
                    def fasta_files = file(db_dir).list().findAll { it.toString().endsWith('.fasta') }
                    assert fasta_files.size() > 0
                },
                
                // Check versions
                { assert process.out.tool_version },
                { assert process.out.db_version },
                { assert process.out.versions }
            )
        }
    }

    test("rgi/preparecarddb - validate database structure without input") {

        when {
            process {
                """
                input[0] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                // Check output database structure
                { assert process.out.db },
                { assert path(process.out.db.get(0)).exists() },
                { assert path(process.out.db.get(0)).isDirectory() },
                
                // Check for localDB directory (created by rgi load)
                { assert path("${process.out.db.get(0)}/localDB").exists() },
                
                // Check for card.json
                { assert path("${process.out.db.get(0)}/card.json").exists() },
                
                // Check for wildcard directory
                { assert path("${process.out.db.get(0)}/wildcard").exists() },
                
                // Check for FASTA files
                {
                    def db_dir = process.out.db.get(0)
                    def fasta_files = file(db_dir).list().findAll { it.toString().endsWith('.fasta') }
                    assert fasta_files.size() > 0
                },
                
                // Check versions
                { assert process.out.tool_version },
                { assert process.out.db_version },
                { assert process.out.versions }
            )
        }
    }

    test("rgi/preparecarddb - compare outputs between modes") {

        when {
            process {
                """
                input[0] = UNTAR.out.untar.map{ it[1] }
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                // Both modes should produce similar database structure
                {
                    def db_dir = process.out.db.get(0)
                    def required_items = ['localDB', 'card.json']
                    def actual_items = file(db_dir).list()
                    required_items.each { item ->
                        assert actual_items.any { it.toString().contains(item) }
                    }
                },
                // Check versions file format
                {
                    def versions_content = path(process.out.versions.get(0)).text
                    assert versions_content.contains('"rgi":')
                    assert versions_content.contains('"rgi-database":')
                }
            )
        }
    }

    test("rgi/preparecarddb - validate version consistency") {

        when {
            process {
                """
                input[0] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                // Check that tool_version and db_version are captured
                { assert process.out.tool_version.get(0) != null },
                { assert process.out.db_version.get(0) != null },
                
                // Check that versions are consistent in versions.yml
                {
                    def versions_content = path(process.out.versions.get(0)).text
                    def tool_version = process.out.tool_version.get(0)
                    def db_version = process.out.db_version.get(0)
                    
                    // Versions should be present in the file
                    assert versions_content.contains('rgi:')
                    assert versions_content.contains('rgi-database:')
                }
            )
        }
    }

    test("rgi/preparecarddb - test with custom args") {

        config "./nextflow.config"

        when {
            params {
                rgi_preparecarddb_args = '--debug'
            }
            process {
                """
                input[0] = []
                """
            }
        }

        then {
            assertAll(
                { assert process.success },
                { assert snapshot(
                    process.out.versions,
                    process.out.tool_version,
                    process.out.db_version
                    ).match() }
            )
        }
    }
}