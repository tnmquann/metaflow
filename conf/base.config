/*
 * -------------------------------------------------
 *  Base configuration file
 * -------------------------------------------------
 */

// ============================================================================
// GLOBAL CONFIGURATION
// ============================================================================

params {
    // Input/Output
    input                   = null
    trimmed_fastq          = null
    input_format           = 'csv' // "csv" or "directory"
    outdir                 = "./results"
    publish_dir_mode       = 'copy'

    // Global resource limits
    max_cpus    = 20
    max_memory  = '60.GB'
    max_time    = '24.h'

// ============================================================================
// WORKFLOW: READ-BASED PROFILING
// ============================================================================

    enable_readbase = false

    // Preprocessing control
    skip_preprocess = false

    // QC & Preprocessing - Fastp
    fastp_adapter_fasta      = null
    fastp_save_trimmed_fail = false
    fastp_save_merged       = false

    // Host Removal - Hostile. https://github.com/bede/hostile#indexes
    hostile_reference = null
    hostile_index = "human-t2t-hla"
    hostile_ref_name = "human-t2t-hla"

    // Taxonomic classification - Sourmash/YACHT
    sourmash_ksize = 31
    sourmash_thresholdbp = null // Path to taxonomy lineages CSV
    sourmash_database = null // Path to sourmash database(s), space-separated for multiple
    sourmash_taxonomy_csv = null
    sourmash_output_format = 'csv_summary'
    sourmash_profile = 'dna,k=31,k=51,scaled=1000,abund'

    skip_yacht = false // Skip YACHT filtering and processing
    yacht_database = null // Path to yacht database - please note that yacht ksize must match the ksize used to build sourmash database
    yacht_ksize = 31

    enable_copysketch_singles = true
    enable_copymergedseqs = true
    enable_copysketch = true
    enable_copyintermediate = true

// ============================================================================
// WORKFLOW: READ-BASED AMR DETECTION (RGI-BWT)
// ============================================================================

    enable_rgi_bwt = false // Whether to enable RGI BWT analysis
    rgi_aligner = 'kma' // Default aligner: kma, bowtie2, bwa
    rgi_include_wildcard = true // Include wildcard variants
    rgi_include_other_models = false // Include other model types (protein variant, rRNA, overexpression)
    rgi_bwt_args = '--local --clean' // Additional RGI bwt arguments
    rgi_preparecarddb_args = null // Additional RGI preparecarddb arguments
    rgi_bwt_prefix = null // Custom prefix for RGI bwt outputs
    
    // RGI directory structure (can be overridden in params.config)
    rgi_preparecarddb_dir = null // Directory for RGI database

// ============================================================================
// WORKFLOW: ASSEMBLY
// ============================================================================

    skip_spades = false
    skip_megahit = false
    skip_quast = false

    // SPAdes
    spades_options = null
    spades_fix_cpus = -1 // Fix SPAdes CPU usage when >= 0

    // MEGAHIT
    megahit_options = null
    megahit_fix_cpu_1 = false // Force MEGAHIT to use a single CPU

    // Mapping preparation
    skip_binning_bamabund = false // Skip BINNING_BAMABUND (mapping reads to assemblies)
    binprepare_mappertool = 'bowtie2' // Options: 'bowtie2' or 'bwamem2'
    bowtie2_mode = null // Bowtie2 alignment mode (e.g., '--very-sensitive')
    save_assembly_mapped_reads = true // Save BAM and BAI files

// ============================================================================
// WORKFLOW: CONTIG ANALYSIS
// ============================================================================

    skip_contig_analysis = false

    // Contig Annotation
    skip_contig_annotation = false
    annotation_tool = 'pyrodigal' // Annotation tool: 'pyrodigal' (default) or 'prokka'
    save_contig_annotations = true

    // Pyrodigal options
    annotation_pyrodigal_singlemode      = false    // Use single-genome mode for long sequences
    annotation_pyrodigal_closed          = false    // Disallow partial genes on contig edges
    annotation_pyrodigal_transtable      = 11       // Translation table for gene annotation
    annotation_pyrodigal_forcenonsd      = false    // Force scan for motifs
    annotation_pyrodigal_usespecialstopcharacter = false // Append asterisks (*) as stop codon

    // Prokka options
    annotation_prokka_singlemode         = false    // Use genome-length optimised mode
    annotation_prokka_rawproduct         = false    // Suppress default clean-up of annotations
    annotation_prokka_kingdom            = 'Bacteria' // Kingdom: Bacteria, Archaea, Mitochondria, Viruses
    annotation_prokka_gcode              = 11       // Translation table for gene annotation
    annotation_prokka_cdsrnaolap         = false    // Allow tRNA to overlap CDS
    annotation_prokka_rnammer            = false    // Use RNAmmer for rRNA prediction
    annotation_prokka_mincontiglen       = 1        // Minimum contig size for annotation (bp)
    annotation_prokka_evalue             = 0.000001 // E-value cut-off
    annotation_prokka_coverage           = 80       // Minimum coverage
    annotation_prokka_compliant          = true     // Force Genbank/ENA/DDJB naming rules
    annotation_prokka_addgenes           = false    // Add gene features for each CDS hit
    annotation_prokka_retaincontigheaders = false   // Retain contig names

    // Viral, Plasmid detection - geNomad
    genomad_db                   = null     // Path to local geNomad database
    save_genomad_db              = true     // Save downloaded geNomad database
    skip_genomad_e2e             = false    // Skip geNomad analysis
    genomad_min_score            = 0.7      // Minimum score for geNomad classification
    genomad_splits               = 1        // Number of splits for geNomad processing
    genomad_e2e_options          = '--enable-score-calibration'  // Additional geNomad arguments

    // Contigs classification - SKANI
    skani_db                     = null     // Path to SKANI database (required if not skipping)
    skip_skani_search            = true    // Skip SKANI search
    skani_search_options         = null     // Additional SKANI arguments

    // Domain classification - TIARA
    skip_tiara_contigqc = false
    tiara_min_length = 3000 // Minimum contig length for TIARA

// ============================================================================
// WORKFLOW: BINNING
// ============================================================================

    skip_binning = false
    min_contig_size = 1500 // Minimum contig size for binning (bp)
    min_length_unbinned_contigs = 1000000 // Minimum length for splitting unbinned contigs
    max_unbinned_contigs = 100 // Maximum number of unbinned contigs to split

    // Binning tools
    skip_concoct = true
    skip_vamb = true
    skip_metabat2 = false
    skip_maxbin2 = false
    skip_comebin = false
    skip_semibin = false

    // Tool-specific settings
    metabat_rng_seed = 1 // Random seed for MetaBAT2
    semibin_environment = 'human_gut' // https://github.com/BigDataBiology/SemiBin#easy-singleco-assembly-binning-mode

    // Binning refinement
    skip_binning_refinement = false
    refine_tool = "binette" // 'dastool' or 'binette'. Binette requires CheckM2 database.
    refine_bins_dastool_threshold = 0.5
    refine_bins_binette_contamination_weight = 5 // QC Score = Completeness - weight * Contamination
    refine_bins_binette_min_completeness = 40

    // Post-binning
    postbinning_input = 'both' // Options: 'raw_bins_only', 'refined_bins_only', 'both'
    exclude_unbins_from_postbinning = false // Exclude unbinned contigs from downstream analysis

    bin_domain_classification = false
    bin_domain_classification_tool = 'tiara'

// ============================================================================
// WORKFLOW: BIN QUALITY CONTROL
// ============================================================================

    skip_binqc = false
    binqc_tool = 'checkm2' // Options: busco, checkm, checkm2
    assembly_stats_params = null

    // BUSCO
    busco_db = null
    busco_db_lineage = 'auto'
    save_busco_db = false
    busco_clean = true

    // CheckM
    checkm_download_url = 'https://zenodo.org/records/7401545/files/checkm_data_2015_01_16.tar.gz'
    checkm_db = null
    save_checkm_data = false

    // CheckM2
    checkm2_db = null
    checkm2_db_version = 14897628
    save_checkm2_data = false

    // GUNC (chimera detection)
    run_gunc = false
    gunc_database_type = 'progenomes' // Options: progenomes, gtdb
    gunc_db = null
    gunc_save_db = false

// ============================================================================
// WORKFLOW: BIN ANNOTATION
// ============================================================================

    skip_bin_annotation = false
    bin_annotation_tool = 'prokka' // Annotation tool: 'prokka' (default) or 'bakta'
    save_bin_annotations = true

    // Prokka bin annotation settings
    prokka_bins_fast_mode                    = false     // Use fast mode (skip slower annotations)
    prokka_bins_with_compliance              = false     // Enable compliance mode for NCBI submission
    prokka_bins_compliance_centre            = null      // Sequencing centre ID for compliance mode

    // Bakta bin annotation settings
    annotation_bakta_db                      = null      // Path to local Bakta database
    annotation_bakta_db_downloadtype         = 'full'    // Database type: 'full' or 'light'
    save_bakta_db                            = true      // Save downloaded Bakta database
    annotation_bakta_singlemode              = false     // Use single genome mode instead of metagenome
    annotation_bakta_mincontiglen            = 1         // Minimum contig length (bp)
    annotation_bakta_translationtable        = 11        // Translation table
    annotation_bakta_gram                    = '?'       // Gram staining: '+', '-', or '?'
    annotation_bakta_complete                = false     // All sequences are complete replicons
    annotation_bakta_renamecontigheaders     = false     // Rename contig headers
    annotation_bakta_compliant               = false     // Force GenBank/ENA/DDBJ compliance
    annotation_bakta_trna                    = false     // Skip tRNA detection
    annotation_bakta_tmrna                   = false     // Skip tmRNA detection
    annotation_bakta_rrna                    = false     // Skip rRNA detection
    annotation_bakta_ncrna                   = false     // Skip ncRNA detection
    annotation_bakta_ncrnaregion             = false     // Skip ncRNA region detection
    annotation_bakta_crispr                  = false     // Skip CRISPR detection
    annotation_bakta_skipcds                 = false     // Skip CDS detection
    annotation_bakta_pseudo                  = false     // Skip pseudogene detection
    annotation_bakta_skipsorf                = false     // Skip sORF detection
    annotation_bakta_gap                     = false     // Skip gap detection
    annotation_bakta_ori                     = false     // Skip oriC/oriV detection
    annotation_bakta_activate_plot           = false     // Activate plotting
    annotation_bakta_hmms                    = null      // Custom HMM models

// ============================================================================
// WORKFLOW: BIN CLASSIFICATION
// ============================================================================

    skip_bin_classification = false

// ============================================================================
// WORKFLOW: AMR DETECTION
// ============================================================================


}

// ============================================================================
// REPORTING & UTILITIES
// ============================================================================

params {
    // MultiQC
    multiqc_config = null
    multiqc_extra_config = null
    multiqc_logo = null
    multiqc_replace_names = null
    multiqc_sample_names = null

    // Resource profiles
    default_max_cpu = 1
    default_max_mem = '7.GB'
    default_max_time = '4.h'

    single_max_cpu = 1
    single_max_mem = '6.GB'
    single_max_time = '4.h'

    low_max_cpu = 4
    low_max_mem = '12.GB'
    low_max_time = '4.h'

    medium_max_cpu = 12
    medium_max_mem = '60.GB'
    medium_max_time = '8.h'

    high_max_cpu = 25
    high_max_mem = '120.GB'
    high_max_time = '16.h'

    long_max_time = '20.h'
    highmem_max_mem = '200.GB'
}

// ============================================================================
// PROCESS RESOURCE CONFIGURATION
// ============================================================================

process {
    def default_cpu = params.default_max_cpu
    def default_mem = params.default_max_mem as nextflow.util.MemoryUnit
    def default_time = params.default_max_time as nextflow.util.Duration

    def single_cpu = params.single_max_cpu
    def single_mem = params.single_max_mem as nextflow.util.MemoryUnit
    def single_time = params.single_max_time as nextflow.util.Duration

    def low_cpu = params.low_max_cpu
    def low_mem = params.low_max_mem as nextflow.util.MemoryUnit
    def low_time = params.low_max_time as nextflow.util.Duration

    def medium_cpu = params.medium_max_cpu
    def medium_mem = params.medium_max_mem as nextflow.util.MemoryUnit
    def medium_time = params.medium_max_time as nextflow.util.Duration

    def high_cpu = params.high_max_cpu
    def high_mem = params.high_max_mem as nextflow.util.MemoryUnit
    def high_time = params.high_max_time as nextflow.util.Duration

    def long_time = params.long_max_time as nextflow.util.Duration
    def highmem_mem = params.highmem_max_mem as nextflow.util.MemoryUnit

    // Default process resource requirements
    cpus = { check_max( default_cpu * task.attempt, 'cpus' ) }
    memory = { check_max( default_mem * task.attempt, 'memory' ) }
    time = { check_max( default_time * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in ((130..145) + [104, 134, 137, 139, 140, 143]) ? 'retry' : 'finish' }
    maxRetries = 3
    maxErrors = '-1'

    // Resource labels
    withLabel: process_single {
        cpus = { check_max( single_cpu, 'cpus' ) }
        memory = { check_max( single_mem * task.attempt, 'memory' ) }
        time = { check_max( single_time * task.attempt, 'time' ) }
    }
    withLabel: process_low {
        cpus = { check_max( low_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( low_mem * task.attempt, 'memory' ) }
        time = { check_max( low_time * task.attempt, 'time' ) }
    }
    withLabel: process_medium {
        cpus = { check_max( medium_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( medium_mem * task.attempt, 'memory' ) }
        time = { check_max( medium_time * task.attempt, 'time' ) }
    }
    withLabel: process_high {
        cpus = { check_max( high_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( high_mem * task.attempt, 'memory' ) }
        time = { check_max( high_time * task.attempt, 'time' ) }
    }
    withLabel: process_long {
        time = { check_max( long_time * task.attempt, 'time' ) }
    }
    withLabel: process_highmem {
        memory = { check_max( highmem_mem * task.attempt, 'memory' ) }
    }

    // Assembly tools
    withName: MEGAHIT {
        cpus          = { check_max( (params.megahit_fix_cpu_1 ? 1 : (8 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 40.GB * task.attempt, 'memory' ) }
        time          = { check_max( 16.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 250) ? 'retry' : 'finish' }
    }

    withName: METASPADES {
        cpus          = { check_max( (params.spades_fix_cpus != -1 ? params.spades_fix_cpus : (10 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 64.GB * (2 ** (task.attempt - 1)), 'memory' ) }
        time          = { check_max( 24.h * (2 ** (task.attempt - 1)), 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 21 + 12 + 1) ? 'retry' : 'finish' }
        maxRetries    = 5
    }


    // Mapping tools
    withName: BOWTIE2_ASSEMBLY_BUILD {
        cpus          = { check_max( 4 * task.attempt, 'cpus' ) }
        memory        = { check_max( 8.GB * task.attempt, 'memory' ) }
        time          = { check_max( 4.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : 'finish' }
    }
    
    withName: BOWTIE2_ASSEMBLY_ALIGN {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 16.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 247) ? 'retry' : 'finish' }
    }
    
    withName: BWAMEM2_ASSEMBLY_INDEX {
        memory        = { (280.MB * Math.ceil(fasta.size() / 10000000)) * task.attempt }
        time          = { check_max( 4.h * task.attempt, 'time' ) }
    }
    
    withName: BWAMEM2_ASSEMBLY_MEM {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 16.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : 'finish' }
    }

    // Binning tools
    withName: METABAT2_JGISUMMARIZEBAMCONTIGDEPTHS {
        cpus = { check_max( 4 * task.attempt, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time = { check_max( 4.h * task.attempt, 'time' ) }
    }
    withName: METABAT2_METABAT2 {
        cpus = { check_max( 8 * task.attempt, 'cpus' ) }
        memory = { check_max( 20.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h * task.attempt, 'time' ) }
    }
    withName: MAXBIN2 {
        cpus = { check_max( 8 * task.attempt, 'cpus' ) }
        memory = { check_max( 20.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }
    withName: 'CONCOCT_.*' {
        cpus = { check_max( 25 * task.attempt, 'cpus' ) }
        memory = { check_max( 20.GB * task.attempt, 'memory' ) }
        time = { check_max( 144.h * task.attempt, 'time' ) }
    }
    withName: COMEBIN_RUNCOMEBIN {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
        time = { check_max( 8.h * task.attempt, 'time' ) }
    }
    withName: SEMIBIN_SINGLEEASYBIN {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
        time = { check_max( 8.h * task.attempt, 'time' ) }
    }
    withName: VAMB_BIN {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }
    withName: DASTOOL_DASTOOL {
        cpus = { check_max( 8 * task.attempt, 'cpus' ) }
        memory = { check_max( 20.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : task.exitStatus == 1 ? 'ignore' : 'finish' }
    }

    // Bin QC tools
    withName: BUSCO_BUSCO {
        cpus = { 10 * task.attempt }
        memory = { 12.GB * task.attempt }
        time = { 4.h * task.attempt }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : 'ignore' }
    }

    // Ref: https://github.com/Ecogenomics/CheckM/wiki/Installation#system-requirements
    withName: CHECKM_LINEAGEWF {
        cpus = { 8 * task.attempt }
        memory = { 42.GB * task.attempt }
        time = { 6.h * task.attempt }
    }

    // CheckM2 returns exit code 1 when Diamond doesn't find any hits
    withName: CHECKM2_PREDICT {
        cpus = { 4 * task.attempt }
        memory = { 16.GB * task.attempt }
        time = { 2.h * task.attempt }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : task.exitStatus == 1 ? 'ignore' : 'finish' }
    }
    withName: CHECKM_QA {
        cpus = { 2 * task.attempt }
        memory = { 8.GB * task.attempt }
        time = { 1.h * task.attempt }
    }
    withName: 'QUAST_BINS|QUAST_BINS_SUMMARY' {
        cpus = { 4 * task.attempt }
        memory = { 8.GB * task.attempt }
        time = { 2.h * task.attempt }
    }
    withName: GUNC_RUN {
        cpus = { 4 * task.attempt }
        memory = { 8.GB * task.attempt }
        time = { 2.h * task.attempt }
    }

    // Annotation tools
    withName: 'BAKTA_.*' {
        cpus = { check_max( 25 * task.attempt, 'cpus' ) }
        memory = { check_max( 36.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h * task.attempt, 'time' ) }
    }
    withName: PROKKA_BINS {
        cpus = { check_max( 16 * task.attempt, 'cpus' ) }
        memory = { check_max( 36.GB * task.attempt, 'memory' ) }
        time = { check_max( 8.h * task.attempt, 'time' ) }
    }

    // Classification tools
    withName: SOURMASH_TAXANNOTATE {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }
    withName: SOURMASH_TAXGENOME {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }
    withName: SOURMASH_TAXMETAGENOME {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }
    withName: SOURMASH_FASTMULTIGATHER_BINS {
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }

    // Utility processes
    withName: 'FASTATOCONTIG2BIN_.*' {
        cpus = { check_max( 2 * task.attempt, 'cpus' ) }
        memory = { check_max( 4.GB * task.attempt, 'memory' ) }
        time = { check_max( 2.h * task.attempt, 'time' ) }
    }
    withName: 'RENAME_PREBINREFINE|RENAME_POSTBINREFINE' {
        cpus = { check_max( 1, 'cpus' ) }
        memory = { check_max( 2.GB * task.attempt, 'memory' ) }
        time = { check_max( 1.h * task.attempt, 'time' ) }
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}

// ============================================================================
// EXECUTOR & REPORTING
// ============================================================================

executor {
    name = 'local'
    queueSize = 8
}

trace {
    enabled = true
    // generate a timestamp at runtime: YYYYMMDD_HHMMSS
    def ts = java.time.ZonedDateTime.now().format(java.time.format.DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"))
    file = "${params.outdir}/pipeline_reports/pipeline_trace_${ts}.txt"
    fields = 'task_id,name,status,exit,realtime,%cpu,peak_rss,peak_vmem,container'
}
