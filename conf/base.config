/*
 * -------------------------------------------------
 *  Base configuration file
 * -------------------------------------------------
 */

//
// INPUT/OUTPUT PARAMETERS
//
params {
    // Input configuration
    input                   = null      // Path to input CSV file
    trimmed_fastq          = null      // Path to trimmed FASTQ directory
    input_format           = 'csv'      // Input format: 'csv' or 'directory'

    // Output configuration
    outdir                 = "./results"
    publish_dir_mode       = 'copy'

    // Directory structure configuration
    merged_seq_dir         = "${params.outdir}/Merged sequences"
    sketches_dir          = "${params.outdir}/Sourmash - YACHT/sketches"
    yacht_results_dir     = "${params.outdir}/Sourmash - YACHT"
    fastmultigather_dir   = "${params.outdir}/Sourmash - YACHT"
    processed_results_dir = "${params.outdir}/Sourmash - YACHT"

    // QC and Preprocessing output directories
    qc_raw_dir = "${params.outdir}/QC/Raw_reads"
    qc_trim_dir = "${params.outdir}/QC/Trimming"
    qc_rmhost_dir = "${params.outdir}/QC/Remove host genome"
    trim_dir = "${params.outdir}/Trimming"
    rmhost_dir = "${params.outdir}/Remove host genome"

    // Sourmash - YACHT parameters
    ksize = 31
    sourmash_database = null
    yacht_database = null

    // Resource parameters - Add these
    max_cpus = 4
    max_memory = '16.GB'
    max_time = '24.h'

    // Hostile reference parameters
    hostile_reference = null
    hostile_index = "human-t2t-hla"  // Set default reference name
    hostile_ref_name = "human-t2t-hla"  // Add this new parameter for explicit reference name

    // RGI options
    enable_rgi_bwt = false    // Whether to enable RGI BWT analysis
    rgi_aligner = 'kma'                    // Default aligner: kma, bowtie2, bwa
    rgi_include_wildcard = true           // Include wildcard variants
    rgi_include_other_models = true       // Include other model types (protein variant, rRNA, overexpression)
    rgi_bwt_args = '--clean'                    // Additional RGI bwt arguments
    rgi_preparecarddb_args = null          // Additional RGI preparecarddb arguments
    rgi_bwt_prefix = null                  // Custom prefix for RGI bwt outputs
    
    // RGI directory structure (can be overridden in params.config)
    rgi_dir = "${params.outdir}/RGI"                  // Base directory for RGI outputs
    rgi_preparecarddb_dir = null  // Directory for RGI database


    // Assembly options
    enable_readbase = false                 // Enable read-based profiling subworkflow
    skip_quast = false                      // Skip QUAST_METAQUAST analysis
    skip_spades = false                     // Skip running SPAdes assembly
    skip_megahit = false                    // Skip running MEGAHIT assembly
    spades_options = null                   // Additional arguments for SPAdes
    megahit_options = null                  // Additional arguments for MEGAHIT
    spades_fix_cpus = -1                    // Fix SPAdes CPU usage when >= 0
    megahit_fix_cpu_1 = false               // Force MEGAHIT to use a single CPU

    // Optional parameters for nf-core modules
    multiqc_config = null
    multiqc_extra_config = null
    multiqc_logo = null
    multiqc_replace_names = null
    multiqc_sample_names  = null

    // Fastp parameters
    fastp_adapter_fasta      = null
    fastp_save_trimmed_fail = false
    fastp_save_merged       = false

    // Contig Analysis options
    skip_contig_analysis         = false    // Skip the entire CONTIG_ANALYSIS subworkflow
    
    // geNomad options
    genomad_db                   = null     // Path to local geNomad database
    save_genomad_db              = true     // Save downloaded geNomad database
    skip_genomad_e2e             = false    // Skip geNomad analysis
    genomad_min_score            = 0.7      // Minimum score for geNomad classification
    genomad_splits               = 1        // Number of splits for geNomad processing
    genomad_e2e_options          = '--enable-score-calibration'  // Additional geNomad arguments
    
    // SKANI options
    skani_db                     = null     // Path to SKANI database (required if not skipping)
    skip_skani_search            = false    // Skip SKANI search
    skani_search_options         = null     // Additional SKANI arguments
    
    // TIARA options
    skip_tiara_contigqc          = false    // Skip TIARA domain classification
    tiara_min_length             = 3000     // Minimum contig length for TIARA
    
    // BWA-MEM2 and SAMTOOLS options (used internally)
    // These can be left as defaults unless user wants to customize
}

//
// RESOURCE MANAGEMENT
//
params {
    // Global resource limits
    max_cpus    = 20
    max_memory  = '60.GB'
    max_time    = '24.h'

    // Resource profiles
    default_max_cpu = 1
    default_max_mem = '7.GB'
    default_max_time = '4.h'

    single_max_cpu = 1
    single_max_mem = '6.GB'
    single_max_time = '4.h'

    low_max_cpu = 4
    low_max_mem = '12.GB'
    low_max_time = '4.h'

    medium_max_cpu = 12
    medium_max_mem = '60.GB'
    medium_max_time = '8.h'

    high_max_cpu = 25
    high_max_mem = '120.GB'
    high_max_time = '16.h'

    long_max_time = '20.h'
    highmem_max_mem = '200.GB'
}

//
// PROCESS CONFIGURATION
//
process {
    // Define the resource values using params
    def default_cpu = params.default_max_cpu
    def default_mem = params.default_max_mem as nextflow.util.MemoryUnit
    def default_time = params.default_max_time as nextflow.util.Duration

    def single_cpu = params.single_max_cpu
    def single_mem = params.single_max_mem as nextflow.util.MemoryUnit
    def single_time = params.single_max_time as nextflow.util.Duration

    def low_cpu = params.low_max_cpu
    def low_mem = params.low_max_mem as nextflow.util.MemoryUnit
    def low_time = params.low_max_time as nextflow.util.Duration

    def medium_cpu = params.medium_max_cpu
    def medium_mem = params.medium_max_mem as nextflow.util.MemoryUnit
    def medium_time = params.medium_max_time as nextflow.util.Duration

    def high_cpu = params.high_max_cpu
    def high_mem = params.high_max_mem as nextflow.util.MemoryUnit
    def high_time = params.high_max_time as nextflow.util.Duration

    def long_time = params.long_max_time as nextflow.util.Duration
    def highmem_mem = params.highmem_max_mem as nextflow.util.MemoryUnit

    // Default process resource requirements
    cpus = { check_max( default_cpu * task.attempt, 'cpus' ) }
    memory = { check_max( default_mem * task.attempt, 'memory' ) }
    time = { check_max( default_time * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in ((130..145) + [104, 134, 137, 139, 140, 143]) ? 'retry' : 'finish' }
    maxRetries = 3
    maxErrors = '-1'

    // Process-specific resource requirements
    withLabel: process_single {
        cpus = { check_max( single_cpu, 'cpus' ) }
        memory = { check_max( single_mem * task.attempt, 'memory' ) }
        time = { check_max( single_time * task.attempt, 'time' ) }
    }
    withLabel: process_low {
        cpus = { check_max( low_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( low_mem * task.attempt, 'memory' ) }
        time = { check_max( low_time * task.attempt, 'time' ) }
    }
    withLabel: process_medium {
        cpus = { check_max( medium_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( medium_mem * task.attempt, 'memory' ) }
        time = { check_max( medium_time * task.attempt, 'time' ) }
    }
    withLabel: process_high {
        cpus = { check_max( high_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( high_mem * task.attempt, 'memory' ) }
        time = { check_max( high_time * task.attempt, 'time' ) }
    }
    withLabel: process_long {
        time = { check_max( long_time * task.attempt, 'time' ) }
    }
    withName: MEGAHIT {
        cpus          = { check_max( (params.megahit_fix_cpu_1 ? 1 : (8 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 40.GB * task.attempt, 'memory' ) }
        time          = { check_max( 16.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 250) ? 'retry' : 'finish' }
    }

    withName: METASPADES {
        cpus          = { check_max( (params.spades_fix_cpus != -1 ? params.spades_fix_cpus : (10 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 64.GB * (2 ** (task.attempt - 1)), 'memory' ) }
        time          = { check_max( 24.h * (2 ** (task.attempt - 1)), 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 21 + 12 + 1) ? 'retry' : 'finish' }
        maxRetries    = 5
    }
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}

//
// EXECUTOR CONFIGURATION
//
executor {
    name = 'local'
    queueSize = 8
}

//
// REPORTING CONFIGURATION
//
trace {
    enabled = false
    file = "${params.outdir}/pipeline_reports/pipeline_trace.txt"
    fields = 'task_id,name,status,exit,realtime,%cpu,peak_rss,peak_vmem,container'
}
