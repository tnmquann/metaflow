/*
 * -------------------------------------------------
 *  Base configuration file
 * -------------------------------------------------
 */

//
// INPUT/OUTPUT PARAMETERS
//
params {
    // Input configuration
    input                   = null      // Path to input CSV file
    trimmed_fastq          = null      // Path to trimmed FASTQ directory
    input_format           = 'csv'      // Input format: 'csv' or 'directory'

    // Output configuration
    outdir                 = "./results"
    publish_dir_mode       = 'copy'

    // Directory structure configuration
    merged_seq_dir         = "${params.outdir}/Merged sequences"
    sketches_dir          = "${params.outdir}/Sourmash - YACHT/sketches"
    yacht_results_dir     = "${params.outdir}/Sourmash - YACHT"
    fastmultigather_dir   = "${params.outdir}/Sourmash - YACHT"
    processed_results_dir = "${params.outdir}/Sourmash - YACHT"

    // QC and Preprocessing output directories
    qc_raw_dir = "${params.outdir}/QC/Raw_reads"
    qc_trim_dir = "${params.outdir}/QC/Trimming"
    qc_rmhost_dir = "${params.outdir}/QC/Remove host genome"
    trim_dir = "${params.outdir}/Trimming"
    rmhost_dir = "${params.outdir}/Remove host genome"

    // Sourmash - YACHT parameters
    ksize = 31
    sourmash_database = null
    yacht_database = null

    // Resource parameters - Add these
    max_cpus = 4
    max_memory = '16.GB'
    max_time = '24.h'

    // Hostile reference parameters
    hostile_reference = null
    hostile_index = "human-t2t-hla"  // Set default reference name
    hostile_ref_name = "human-t2t-hla"  // Add this new parameter for explicit reference name

    // RGI options
    enable_rgi_bwt = false    // Whether to enable RGI BWT analysis
    rgi_aligner = 'kma'                    // Default aligner: kma, bowtie2, bwa
    rgi_include_wildcard = true           // Include wildcard variants
    rgi_include_other_models = true       // Include other model types (protein variant, rRNA, overexpression)
    rgi_bwt_args = '--clean'                    // Additional RGI bwt arguments
    rgi_preparecarddb_args = null          // Additional RGI preparecarddb arguments
    rgi_bwt_prefix = null                  // Custom prefix for RGI bwt outputs
    
    // RGI directory structure (can be overridden in params.config)
    rgi_dir = "${params.outdir}/RGI"                  // Base directory for RGI outputs
    rgi_preparecarddb_dir = null  // Directory for RGI database


    // Assembly options
    enable_readbase = false                 // Enable read-based profiling subworkflow
    skip_quast = false                      // Skip QUAST_METAQUAST analysis
    skip_spades = false                     // Skip running SPAdes assembly
    skip_megahit = false                    // Skip running MEGAHIT assembly
    skip_binning_bamabund = false           // Skip BINNING_BAMABUND (mapping reads to assemblies)
    spades_options = null                   // Additional arguments for SPAdes
    megahit_options = null                  // Additional arguments for MEGAHIT
    spades_fix_cpus = -1                    // Fix SPAdes CPU usage when >= 0
    megahit_fix_cpu_1 = false               // Force MEGAHIT to use a single CPU

    // Optional parameters for nf-core modules
    multiqc_config = null
    multiqc_extra_config = null
    multiqc_logo = null
    multiqc_replace_names = null
    multiqc_sample_names  = null

    // Fastp parameters
    fastp_adapter_fasta      = null
    fastp_save_trimmed_fail = false
    fastp_save_merged       = false

    // Contig Analysis options
    skip_contig_analysis         = false    // Skip the entire CONTIG_ANALYSIS subworkflow

    // Contig Annotation options
    skip_contig_annotation               = false    // Skip contig annotation in CONTIG_ANALYSIS workflow
    annotation_tool                      = 'pyrodigal' // Annotation tool: 'pyrodigal' (default) or 'prokka'
    save_contig_annotations              = true     // Save gene annotations in results directory

    // Pyrodigal options
    annotation_pyrodigal_singlemode      = false    // Use single-genome mode for long sequences
    annotation_pyrodigal_closed          = false    // Disallow partial genes on contig edges
    annotation_pyrodigal_transtable      = 11       // Translation table for gene annotation
    annotation_pyrodigal_forcenonsd      = false    // Force scan for motifs
    annotation_pyrodigal_usespecialstopcharacter = false // Append asterisks (*) as stop codon

    // Prokka options
    annotation_prokka_singlemode         = false    // Use genome-length optimised mode
    annotation_prokka_rawproduct         = false    // Suppress default clean-up of annotations
    annotation_prokka_kingdom            = 'Bacteria' // Kingdom: Bacteria, Archaea, Mitochondria, Viruses
    annotation_prokka_gcode              = 11       // Translation table for gene annotation
    annotation_prokka_cdsrnaolap         = false    // Allow tRNA to overlap CDS
    annotation_prokka_rnammer            = false    // Use RNAmmer for rRNA prediction
    annotation_prokka_mincontiglen       = 1        // Minimum contig size for annotation (bp)
    annotation_prokka_evalue             = 0.000001 // E-value cut-off
    annotation_prokka_coverage           = 80       // Minimum coverage
    annotation_prokka_compliant          = true     // Force Genbank/ENA/DDJB naming rules
    annotation_prokka_addgenes           = false    // Add gene features for each CDS hit
    annotation_prokka_retaincontigheaders = false   // Retain contig names

    // geNomad options
    genomad_db                   = null     // Path to local geNomad database
    save_genomad_db              = true     // Save downloaded geNomad database
    skip_genomad_e2e             = false    // Skip geNomad analysis
    genomad_min_score            = 0.7      // Minimum score for geNomad classification
    genomad_splits               = 1        // Number of splits for geNomad processing
    genomad_e2e_options          = '--enable-score-calibration'  // Additional geNomad arguments
    
    // SKANI options
    skani_db                     = null     // Path to SKANI database (required if not skipping)
    skip_skani_search            = false    // Skip SKANI search
    skani_search_options         = null     // Additional SKANI arguments
    
    // TIARA options
    skip_tiara_contigqc          = false    // Skip TIARA domain classification
    tiara_min_length             = 3000     // Minimum contig length for TIARA
    
    // Binning preparation options
    binprepare_mappertool        = 'bowtie2'  // Options: 'bowtie2' or 'bwamem2'
    bowtie2_mode                 = null       // Bowtie2 alignment mode (e.g., '--very-sensitive')
    save_assembly_mapped_reads   = true       // Save BAM and BAI files

    // Optional: Set a custom output directory for assembly results
    // assembly_outdir = "${params.outdir}/Custom_Assembly_Results"

    // Optional: Enable/disable specific analysis steps
    // enable_quast = true
    // enable_spades = false
    // enable_megahit = true

    // Binning options
    skip_binning                         = false     // Skip the entire binning workflow
    skip_metabat2                        = false     // Skip MetaBAT2 binning
    skip_maxbin2                         = false     // Skip MaxBin2 binning
    skip_concoct                         = false     // Skip CONCOCT binning
    min_contig_size                      = 1500      // Minimum contig size for binning (bp)
    min_length_unbinned_contigs          = 1000000   // Minimum length for splitting unbinned contigs
    max_unbinned_contigs                 = 100       // Maximum number of unbinned contigs to split
    metabat_rng_seed                     = 1         // Random seed for MetaBAT2

    // Binning refinement options
    refine_tool = "dastool"  // Tool choice: 'dastool' or 'binette'
    refine_bins_dastool_threshold = 0.5  // DAS Tool score threshold
    refine_bins_binette_contamination_weight = 5  // Binette contamination weight
    refine_bins_binette_min_completeness = 40  // Binette minimum completeness
    checkm2_db = "/mnt/data1/quantnm/database/soma_db/checkm2_database/CheckM2_database/checkm2_db_v5571251.dmnd"  // Path to CheckM2 database
    skip_binning_refinement = false  // Skip binning refinement workflow

    // Binning post-processing options
    postbinning_input                = 'both'  // Options: 'raw_bins_only', 'refined_bins_only', 'both'
    exclude_unbins_from_postbinning  = false                // Exclude unbinned contigs from downstream analysis

    // Bin QC settings
    skip_binqc                           = false
    binqc_tool                           = 'checkm2' // Options: busco, checkm, checkm2
    
    // BUSCO settings
    busco_db                             = null
    busco_db_lineage                     = 'auto'
    save_busco_db                        = false
    busco_clean                          = true
    
    // CheckM settings
    checkm_download_url                  = 'https://zenodo.org/records/7401545/files/checkm_data_2015_01_16.tar.gz'
    checkm_db                            = null
    save_checkm_data                     = false
    
    // CheckM2 settings
    checkm2_db                           = null
    checkm2_db_version                   = 14897628 // Zenodo record ID for CheckM2 database v3
    save_checkm2_data                    = false
    
    // GUNC settings (chimera detection)
    run_gunc                             = false
    gunc_database_type                   = 'progenomes' // Options: progenomes, gtdb
    gunc_db                              = null
    gunc_save_db                         = false
}

//
// RESOURCE MANAGEMENT
//
params {
    // Global resource limits
    max_cpus    = 20
    max_memory  = '60.GB'
    max_time    = '24.h'

    // Resource profiles
    default_max_cpu = 1
    default_max_mem = '7.GB'
    default_max_time = '4.h'

    single_max_cpu = 1
    single_max_mem = '6.GB'
    single_max_time = '4.h'

    low_max_cpu = 4
    low_max_mem = '12.GB'
    low_max_time = '4.h'

    medium_max_cpu = 12
    medium_max_mem = '60.GB'
    medium_max_time = '8.h'

    high_max_cpu = 25
    high_max_mem = '120.GB'
    high_max_time = '16.h'

    long_max_time = '20.h'
    highmem_max_mem = '200.GB'
}

//
// PROCESS CONFIGURATION
//
process {
    // Define the resource values using params
    def default_cpu = params.default_max_cpu
    def default_mem = params.default_max_mem as nextflow.util.MemoryUnit
    def default_time = params.default_max_time as nextflow.util.Duration

    def single_cpu = params.single_max_cpu
    def single_mem = params.single_max_mem as nextflow.util.MemoryUnit
    def single_time = params.single_max_time as nextflow.util.Duration

    def low_cpu = params.low_max_cpu
    def low_mem = params.low_max_mem as nextflow.util.MemoryUnit
    def low_time = params.low_max_time as nextflow.util.Duration

    def medium_cpu = params.medium_max_cpu
    def medium_mem = params.medium_max_mem as nextflow.util.MemoryUnit
    def medium_time = params.medium_max_time as nextflow.util.Duration

    def high_cpu = params.high_max_cpu
    def high_mem = params.high_max_mem as nextflow.util.MemoryUnit
    def high_time = params.high_max_time as nextflow.util.Duration

    def long_time = params.long_max_time as nextflow.util.Duration
    def highmem_mem = params.highmem_max_mem as nextflow.util.MemoryUnit

    // Default process resource requirements
    cpus = { check_max( default_cpu * task.attempt, 'cpus' ) }
    memory = { check_max( default_mem * task.attempt, 'memory' ) }
    time = { check_max( default_time * task.attempt, 'time' ) }

    errorStrategy = { task.exitStatus in ((130..145) + [104, 134, 137, 139, 140, 143]) ? 'retry' : 'finish' }
    maxRetries = 3
    maxErrors = '-1'

    // Process-specific resource requirements
    withLabel: process_single {
        cpus = { check_max( single_cpu, 'cpus' ) }
        memory = { check_max( single_mem * task.attempt, 'memory' ) }
        time = { check_max( single_time * task.attempt, 'time' ) }
    }
    withLabel: process_low {
        cpus = { check_max( low_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( low_mem * task.attempt, 'memory' ) }
        time = { check_max( low_time * task.attempt, 'time' ) }
    }
    withLabel: process_medium {
        cpus = { check_max( medium_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( medium_mem * task.attempt, 'memory' ) }
        time = { check_max( medium_time * task.attempt, 'time' ) }
    }
    withLabel: process_high {
        cpus = { check_max( high_cpu * task.attempt, 'cpus' ) }
        memory = { check_max( high_mem * task.attempt, 'memory' ) }
        time = { check_max( high_time * task.attempt, 'time' ) }
    }
    withLabel: process_long {
        time = { check_max( long_time * task.attempt, 'time' ) }
    }
    withName: MEGAHIT {
        cpus          = { check_max( (params.megahit_fix_cpu_1 ? 1 : (8 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 40.GB * task.attempt, 'memory' ) }
        time          = { check_max( 16.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 250) ? 'retry' : 'finish' }
    }

    withName: METASPADES {
        cpus          = { check_max( (params.spades_fix_cpus != -1 ? params.spades_fix_cpus : (10 * task.attempt)), 'cpus' ) }
        memory        = { check_max( 64.GB * (2 ** (task.attempt - 1)), 'memory' ) }
        time          = { check_max( 24.h * (2 ** (task.attempt - 1)), 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 21 + 12 + 1) ? 'retry' : 'finish' }
        maxRetries    = 5
    }
    
    withName: BOWTIE2_ASSEMBLY_BUILD {
        cpus          = { check_max( 4 * task.attempt, 'cpus' ) }
        memory        = { check_max( 8.GB * task.attempt, 'memory' ) }
        time          = { check_max( 4.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : 'finish' }
    }
    
    withName: BOWTIE2_ASSEMBLY_ALIGN {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 16.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 247) ? 'retry' : 'finish' }
    }
    
    withName: BWAMEM2_ASSEMBLY_INDEX {
        memory        = { (280.MB * Math.ceil(fasta.size() / 10000000)) * task.attempt }
        time          = { check_max( 4.h * task.attempt, 'time' ) }
    }
    
    withName: BWAMEM2_ASSEMBLY_MEM {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 16.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : 'finish' }
    }

    withName: METABAT2_JGISUMMARIZEBAMCONTIGDEPTHS {
        cpus          = { check_max( 4 * task.attempt, 'cpus' ) }
        memory        = { check_max( 8.GB * task.attempt, 'memory' ) }
        time          = { check_max( 4.h * task.attempt, 'time' ) }
    }

    withName: METABAT2_METABAT2 {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 20.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
    }

    withName: MAXBIN2 {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 20.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in [1, 255] ? 'ignore' : 'retry' }
    }

    withName: 'CONCOCT_.*' {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 20.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
    }

    withName: DASTOOL_DASTOOL {
        cpus          = { check_max( 8 * task.attempt, 'cpus' ) }
        memory        = { check_max( 20.GB * task.attempt, 'memory' ) }
        time          = { check_max( 8.h * task.attempt, 'time' ) }
        errorStrategy = { task.exitStatus in ((130..145) + 104) ? 'retry' : task.exitStatus == 1 ? 'ignore' : 'finish' }
    }

    withName: 'FASTATOCONTIG2BIN_.*' {
        cpus          = { check_max( 2 * task.attempt, 'cpus' ) }
        memory        = { check_max( 4.GB * task.attempt, 'memory' ) }
        time          = { check_max( 2.h * task.attempt, 'time' ) }
    }

    withName: 'RENAME_PREBINREFINE|RENAME_POSTBINREFINE' {
        cpus          = { check_max( 1, 'cpus' ) }
        memory        = { check_max( 2.GB * task.attempt, 'memory' ) }
        time          = { check_max( 1.h * task.attempt, 'time' ) }
    }

    // Bin QC resource configurations
    withName: BUSCO_BUSCO {
        cpus          = { 10 * task.attempt }
        memory        = { 12.GB * task.attempt }
        time          = { 4.h * task.attempt }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : 'ignore' }
    }

    // Ref: https://github.com/Ecogenomics/CheckM/wiki/Installation#system-requirements
    withName: CHECKM_LINEAGEWF {
        cpus   = { 8 * task.attempt }
        memory = { 42.GB * task.attempt }
        time   = { 6.h * task.attempt }
    }

    // CheckM2 returns exit code 1 when Diamond doesn't find any hits
    withName: CHECKM2_PREDICT {
        cpus          = { 4 * task.attempt }
        memory        = { 16.GB * task.attempt }
        time          = { 2.h * task.attempt }
        errorStrategy = { task.exitStatus in ((130..145) + 104 + 175) ? 'retry' : task.exitStatus == 1 ? 'ignore' : 'finish' }
    }

    withName: CHECKM_QA {
        cpus   = { 2 * task.attempt }
        memory = { 8.GB * task.attempt }
        time   = { 1.h * task.attempt }
    }

    withName: 'QUAST_BINS|QUAST_BINS_SUMMARY' {
        cpus   = { 4 * task.attempt }
        memory = { 8.GB * task.attempt }
        time   = { 2.h * task.attempt }
    }

    withName: GUNC_RUN {
        cpus   = { 4 * task.attempt }
        memory = { 8.GB * task.attempt }
        time   = { 2.h * task.attempt }
    }
}

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}

//
// EXECUTOR CONFIGURATION
//
executor {
    name = 'local'
    queueSize = 8
}

//
// REPORTING CONFIGURATION
//
trace {
    enabled = false
    file = "${params.outdir}/pipeline_reports/pipeline_trace.txt"
    fields = 'task_id,name,status,exit,realtime,%cpu,peak_rss,peak_vmem,container'
}
